<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!-- Mirrored from learnyouahaskell.com/starting-out by HTTrack Website Copier/3.x [XR&CO'2008], Wed, 25 Jun 2014 15:12:16 GMT -->
<head>
<title>Starting Out - Learn You a Haskell for Great Good!</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<base >
<style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style>
<link rel="shortcut icon" href="favicon.png" type="image/png">
        <link rel="prev" href="introduction.html">
        <link rel="next" href="types-and-typeclasses.html">
<link type="text/css" rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css">
<link href="rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
</head>
<body class="introcontent">
<div class="bgwrapper">
    <div id="content">
                <div class="footdiv" style="margin-bottom:25px;">
                <ul>
                    <li style="text-align:left">
                                                        <a href="introduction.html" class="prevlink">Εισαγωγή</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters.html">Περιεχόμενα</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="types-and-typeclasses.html" class="nxtlink">Τύποι και κλάσεις τύπων</a>
                                            </li>
                </ul>
            </div>
        <h1 style="margin-left:-3px">Ας ξεκινήσουμε!</h1>
<a name="ready-set-go"></a><h2>Έτοιμοι? Πάμε!</h2>
<p>
<img src="../s3.amazonaws.com/lyah/startingout.png" class="right" alt="egg" width="214" height="187">
Λοιπόν, ας ξεκινήσουμε!
Αν είστε από αυτούς τους άθλοιους ανθρώπους που δεν διαβάζουν τις εισαγωγές και παραλείψατε την εισαγωγή, 
διαβάστε τουλάχιστον την τελευταία ενότητα της εισαγωγής που εξηγεί 
τι πρέπει να ξέρεται για αυτό το εγχειρίδιο και πώς μπορείτε να φορτώνεται συναρτήσεις.
Το πρώτο πράγμα που θα κάνουμε είναι να τρέξουμε το διαδραστικό περιβάλλον του ghc και να καλέσουμε κάποιες συναρτήσεις για να πάρουμε μια γεύση από Haskell.
Ανοίξτε το τερματικό και γράψτε 
<span class="fixed">ghci</span>. Θα δείτε κάτι σαν το παρακάτω.
</p>
<pre name="code" class="haskell: ghci">
GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
Loading package base ... linking ... done.
Prelude&gt;</pre>
<p>
Συγχαρητήρια, είστε στον GHCI! 
Η προτροπή εδώ είναι <span class="fixed">Prelude&gt;</span> αλλά επειδή θα γίνει πολύ μεγαλύτερο όταν φορτώνουμε πράγματα στην συνεδρία, θα χρησημιποιήσουμε απλώς <span class="fixed">ghci&gt;</span>. 
Αν θέλετε να έχετε την ίδια προτροπή, απλώς γράψτε <span class="fixed">:set prompt "ghci&gt; "</span>. 
</p>
<p>
Ξεκινάμε με απλή αριθμητική.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; 2 + 15
17
ghci&gt; 49 * 100
4900
ghci&gt; 1892 - 1472
420
ghci&gt; 5 / 2
2.5
ghci&gt;</pre>
<p>
Αυτό είναι αρκετά απλό. Μπορούμε επίσης να χρησιμοποιήσουμε πολλούς τελεστές στην ίδια γραμμη και οι σύνηθεις κανόνες προταιρεότητας ακολουθούνται.
Μπορούμε να χρησιμοποιοήσουμε παρενθέσεις για να καθορίσουμε ρητά την προταιρεότητα των τελεστών, ή να την αλλάξουμε.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; (50 * 100) - 4999
1
ghci&gt; 50 * 100 - 4999
1
ghci&gt; 50 * (100 - 4999)
-244950</pre>
<p>
Ενδιαφέρον ε? Χμμμ, ξέρω δεν είναι και τόσο ενδιαφέρον, αλλά μείνεται μαζί μου!
Μια παγίδα που πρέπει να προσέχεται είναι το πώς δημιουργούμε αρνητικούς αριθμούς.
Αν θέλετε να δημιουργήσεται έναν αρνητικό αριθμό, είναι προτειμότερο να τον περικλείσεται σε παρενθέσεις.
Ο GHCI θα γκρινιάξει με την έκφραση <span class="fixed">5 * -3</span>, αλλά η έκφραση <span class="fixed">5 * (-3)</span> θα του αρέσει.
</p>
<p>
Η αριθμητική Boolean είναι επίσης αρκετά απλή. 
Όπως ίσως ξέρεται, το <span class="fixed">&amp;&amp;</span> είναι το λογικό <i>και</i>, το <span class="fixed">||</span> είναι το λογικό <i>ή</i>. Το <span class="fixed">not</span> αντιστρέφει το <span class="fixed">True</span> σε <span class="fixed">False</span> και αντίστροφα.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; True &amp;&amp; False
False
ghci&gt; True &amp;&amp; True
True
ghci&gt; False || True
True 
ghci&gt; not False
True
ghci&gt; not (True &amp;&amp; True)
False</pre>
<p>
Ο έλεγχος για ισότητα γίνεται ως εξής.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; 5 == 5
True
ghci&gt; 1 == 0
False
ghci&gt; 5 /= 5
False
ghci&gt; 5 /= 4
True
ghci&gt; "hello" == "hello"
True </pre>
<p>
Τι γίνεται αν γράψουμε <span class="fixed">5 + "llama"</span> ή <span class="fixed">5 == True</span>;
Λοιπόν, αν δοκιμάζουμε την πρώτη έκφραση, θα πάρουμε ένα μεγάλο τρομακτικό σφάλμα τύπων!
</p>
<pre name="code" class="haskell: ghci">
No instance for (Num [Char])
arising from a use of `+' at &lt;interactive&gt;:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama" </pre>
<p>
Ουπς! 
Αυτό που προσπαθεί να μας πει εδώ ο GHCI είναι ότι το <span class="fixed">"llama"</span> 
δεν είναι αριθμός, άρα δεν ξέρει πως να το προσθέσει στον αριθμό 5.
Ακόμα και αν δεν ήταν <span class="fixed">"llama"</span> αλλά <span class="fixed">"four"</span> ή <span class="fixed">"4"</span>, η Haskell πάλι δεν θα το θεωρούσε αριθμό.
Ο τελεστής <span class="fixed">+</span> απαιτεί το αριστερό και το δεξί μέρος του να είναι αριθμοί.
Αν επιχειρήσουμε <span class="fixed">True == 5</span>, ο GHCI θα μας πει ότι οι τύποι δεν ταιριάζουν. 
Όπως ο τελεστής <span class="fixed">+</span> δουλεύει μόνο σε εκφράσεις που είναι αριθμοί, ο τελεστής 
<span class="fixed">==</span> δουλεέυει μόνο σε πράγματα που μπορούν να συγκριθούν.
Επιπλέον όμως και οι δύο πλευρές πρέπει να είναι πράγματα που έχουν τον ίδιο τύπο.
Δεν μπορείς να συγκρίνεις μήλα με πορτοκάλια!
Θα εξετάσουμε καλύτερα τους τύπους σε λίγο.
Σημείωση: μπορείς να κάνεις <span class="fixed">5 + 4.0</span> επειδή το <span class="fixed">5</span> είναι ύπουλο και μπορεί να συμπεριφερθεί είτε σαν ακέραιος, είτε σαν αριθμός κινητής υποδιαστολής.
Όμως ο <span class="fixed">4.0</span> δεν μπορεί να συμπεριφερθεί σαν ακεραιος, άρα ο <span class="fixed">5</span> είναι αυτός που πρέπει να προσαρμοστεί.
</p>
<p>
Μπορεί να μην το καταλάβατε, αλλά χρησιμοποιείτε ήδη συναρτήσεις!
Για παράδειγμα, ο τελεστής <span class="fixed">*</span> είναι μία συνάρτηση που δέχεται δύο αριθμούς και τους πολλαπλασιάζει.
Όπως είδαμε, τον χρησιμοποιούμε ανάμεσα από τους δύο αριθμούς. 
Για τον λόγο αυτό καλούμε αυτόν τον τελεστή <i>ένθετη</i> συνάρτηση. 
Οι περισσότερες συναρτήσεις που δεν δέχονται αριθμούς είναι 
<i>πρόθετες</i> συναρτήσεις.
Ας τις δούμε.
</p>
<p>
<img src="../s3.amazonaws.com/lyah/ringring.png" alt="phoen" class="right" width="160" height="161">
Οι περισσότερες συναρτήσεις είναι πρόθετες, για αυτό από εδώ και πέρα δεν θα λέμε ρητά ότι μία συνάρτηση έχει πρόθετη μορφή, απλώς θα το υποθέτουμε.
Στις περισσότερες γλώσσες προγραμματισμού καλούμε μια συνμάρτηση γράφοντας το όνομα της συνάρτησης και μετά γράφουμε τα ορισματά της σε παρένθεση, συνήθως χωριζοντάς τα με κόμμα.
Στην Haskell καλούμε μια συνάρτηση γράφοντας το όνομα της συνάρτησης, κενό και μετά τα ορίσματα, χωρισμένα με κενά.
Θα ξεκινήσουμε καλώντας μια από τις πιο βαρετές συναρτήσεις της Haskell.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; succ 8
9 </pre>
<p>
Η συνάρτηση <span class="fixed">succ</span> δέχεται ο,τιδήποτε έχει επόμενο και επιστρέφει τον επομενό του.
Όπως βλέπετε, απλώς χωρίζουμε το όνομα της συνάρτησης από το όρισμά της με κενό.
Η κλήση μιας συνάρτησης με πολλά ορίσματα είναι εξήσου απλή.
Οι συναρτήσεις <span class="fixed">min</span> και <span class="fixed">max</span> 
δέχονται δύο πράγματα που μπορούν να διαταχθούν (για παράδειγμα, δύο αριθμούς).
Η συνάρτηση <span class="fixed">min</span> επιστρέφει το μικρότερο ενώ η συνάρτηση 
<span class="fixed">max</span> επιστρέφει το μεγαλύτερο. 
Δείτε και μόνοι σας:
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; min 9 10
9
ghci&gt; min 3.4 3.2
3.2
ghci&gt; max 100 101
101 </pre>

<p>
Η εφαρμοφή συναρτήσεων (η κλήση μιας συνάρτησης βάζοντας κενό μετά το ονομά της και μετά γράφοντας τα ορίσματά της) έχει την μεγαλύτερη προτεραιότητα από τα πάντα.
Αυτό για εμάς σημαίνει ότι οι δύο ακόλουθες εκφράσεις είναι ισοδύναμες.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; succ 9 + max 5 4 + 1
16
ghci&gt; (succ 9) + (max 5 4) + 1
16
</pre>
<p>
Όμως, αν θέλουμε να πάρουμε τον επόμενο του γινομένου των αριθμών 9 ακι 10, 
δεν μπορούμε να γράψουμε <span class="fixed">succ 9 * 10</span> 
γιατί αυτό θα επιστρέψει τον επόμενο του 9 και μετά θα τον πολλαπλασιάσει με το 10.
Με άλλα λόγια, θα δώσει 100.
Αντίθετα, πρέπει να γράψουμε <span class="fixed">succ (9 * 10)</span> για να πάρουμε 91.
</p>
<p>
Αν μια συνάρτηση δέχεται δύο ορίσματα, 
μπορούμε να την χρησιμοποιήσουμε σαν ένθετη, αν την εγκλείσουμε σε βαρείες.
Για παράδειγμα, η συνάρτηση <span class="fixed">div</span> δέχεται δύο ακεραίους και επιστρέφει την ακέραια διαίρεση αυτών. 
Η έκφραση <span class="fixed">div 92 10</span> δίνει 9. 
Αλλά αν γράψουμε έτσι την διαίρεση, μπορεί να υπάρξει σύγχηση ως προς το ποιός είναι ο διαιρέτης και ποιός ο διαιρετέος.
Για τον λόγο αυτό, μπορούμε να την καλέσουμε σαν ένθετο τελεστή γράφοντας <span class="fixed">92 `div` 10</span>και ξαφνικά όλα είναι ξεκάθαρα! </p>
<p>Πολλοί, που έρχονται από προστακτικές γλώσσες, πιστεύουν ότι οι παρενθέσεις δηλώνουν εφαρμογή συνάρτησης.
Για παράδειγμα, στην C, χρησιμοποιούμε παρενθέσεις για να καλέσουμε συναρτήσεις, όπως <span class="fixed">foo()</span>, <span class="fixed">bar(1)</span> ή <span class="fixed">baz(3, "haha")</span>. 
Όπως είπαμε, στην Haskell για να καλέσουμε συναρτήσεις χρησιμοποιούμε κενά.
Άρα οι προηγούμενες συναρτήσεις στην Haskell για είναι <span class="fixed">foo</span>, <span class="fixed">bar 1</span> και <span class="fixed">baz 3 "haha"</span>. 
Έτσι, η έκφραση <span class="fixed">bar (bar 3)</span>, δεν σημαίνει ότι η συνάρτηση <span class="fixed">bar</span> καλείτε με ορίσματα <span class="fixed">bar</span> και <span class="fixed">3</span>. 
Αλλά σημαίνει ότι πρώτα καλούμε την συνάρτηση <span class="fixed">bar</span> με όρισμα <span class="fixed">3</span>, παίρνουμε το αποτέλεσμα της κλήσης και μετά καλούμε την συνάρτηση <span class="fixed">bar</span> ξανά με το αποτέλεσμα αυτό.
Στην C, αυτό θα γραφόταν <span class="fixed">bar(bar(3))</span>.</p>

<a name="babys-first-functions"></a><h2>Βρεφικές συναρτήσεις</h2>
<p>
Στην προηγούμενη ενότητα πήραμε μια ιδέα του πώς καλούμε συναρτήσεις. 
Τώρα ας δοκιμάσουμε να ορίσουμε τις δικές μας συναρτήσεις!
Ανοίξτε τον αγαπημένο σας επαιξεργαστή κειμένου και βάλτε μέσα την ακόλουθη συνάρτηση που δέχεται έναν αριθμό και τον πολλαπλασιάζει με το δύο. 
</p>
<pre name="code" class="haskell: hs">
doubleMe x = x + x</pre>
<p>
Οι συναρτήσεις ορίζονται με τρόπο παρόμοιο με αυτόν που καλούνται.
Το όνομα της συνάρτησης ακολουθείτε από τα ορίσματά της, χωρισμένα με κενά.
Αλλά όταν ορίζουμε συναρτήσεις, υπάρχει ένα <span class="fixed">=</span> και μετά ορίζουμε τι κάνει η συνάρτηση.
Σώστε αυτό σε κάποιο αρχείο, όπως <span class="fixed">baby.hs</span>.
Τώρα πηγαίντε εκεί που το σώσατε και τρέξτε <span class="fixed">ghci</span> στο τερματικό. 
Όταν είστε στον GHCI, γράψτε <span class="fixed">:l baby</span>. 
Τώρα που το αρχείο σας έχει φορτωθεί, μπορύμε να παίξουμε με την συνάρτηση που ορίσαμε.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; :l baby
[1 of 1] Compiling Main             ( baby.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; doubleMe 9
18
ghci&gt; doubleMe 8.3
16.6 </pre>
<p>
Επειδή ο τελεστής <span class="fixed">+</span> δέχεται ακεραίους αλλά και αριθμόυς κινητής υποδιαστολής
(στην πραγματικότητα δέχεται ό,τιδήποτε μπορεί να θεωρηθεί αριθμός), η συνάρτηση μας επίσης δέχεται κάθε αριθμό.
Ας ορίσμουμε τώρα μια συνάρηση που δέχεται δύο αριθμόυς και πολλαπλασιάζει καθέναν με το δύο και μετά τους προσθέτει.
</p>
<pre name="code" class="haskell: hs">
doubleUs x y = x*2 + y*2 </pre>
<p>
Απλό. Θα μπορούσαμε επίσης να την ορίσουμε ως <span class="fixed">doubleUs x y = x + x + y + y</span>. 
Ας τεστάρουμε την συνάρτηση μας 
(για τον σκοπό αυτό προσθέστε την συνάρτηση στο αρχείο <span class="fixed">baby.hs</span>, σώστε το αρχέιο και μετά γράψτε <span class="fixed">:l baby</span> στον GHCI).
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; doubleUs 4 9
26
ghci&gt; doubleUs 2.3 34.2
73.0
ghci&gt; doubleUs 28 88 + doubleMe 123
478
</pre>
<p>
Όπως περιμένατε, μπορείτε να καλείτε τις δικές σας συναρτήσεις από από άλλες συναρτήσεις που ορίσατε.
Γνωρίζοντας αυτό, μπορούμε να ορίσουμε την συνάρτηση <span class="fixed">doubleUs</span> ξανά, ως εξής:
</p>
<pre name="code" class="haskell: hs">
doubleUs x y = doubleMe x + doubleMe y </pre>
<p>
Αυτό είναι ένα πολύ απλό παράδειγμα ενός μοτίβου που θα δείτε πολύ συχνά σητν Haskell.
Ορίζουμε βασικές συναρτήσεις που είναι προφανώς σωστές και μετά τις χρησιμοποιούμε για να χτήσουμε πιο πολύπλοκες συναρτήσεις.
Με τον τρόπο αυτό αποφεύγουμε την επανάλληψη.
Τι θα συνέβαινε αν κάποιος μαθηματικός καταλάβαινε ότι το 2 είναι στην πραγματικότητα 3 και έπρεπε να αλλάξετε το προγραμμά σας;
Θα μπορούσατε απλώς να αλλάζατε την συνάρτηση
<span class="fixed">doubleMe</span> σε <span class="fixed">x + x + x</span> και επειδή η συνάρτηση <span class="fixed">doubleUs</span> καλεί την <span class="fixed">doubleMe</span>, 
όλα θα δούλευαν στον παράξενο κόσμο στον οποίο το 2 είναι 3.
</p>
<p>Οι συναρτήσεις στην Haskell δεν πρέπει να είναι ορισμένες σε κάποια προκαθορισμένη σειρά, 
άρα είναι το ίδιο αν ορίσεις πρώτα την <span class="fixed">doubleMe</span> και μετά την <span class="fixed">doubleUs</span> ή ανάποδα.</p>
<p>Τώρα θα ορίσουμε μια συνάρτηση που πολλαπλασιάζει έναν αριθμό με το 2, αλλά μόνο αν ο αριθμός αυτός είναι μικρότερος ή ίσος με 100, αφού οι αριθμόι που είναι μεγαλύτεροι από 100 είναι ήδη αρκετά μεγάλοι!
</p>
<pre name="code" class="haskell: hs">
doubleSmallNumber x = if x &gt; 100
                        then x
                        else x*2 </pre>
<img src="../s3.amazonaws.com/lyah/baby.png" alt="this is you" class="left" width="140" height="211">
<p>
Εδώ εισάγουμε τον όρο if της Haskell.
Ίσως ήδη γνωρίζεται τον όρο if από άλλες γλώσσες προγραμματισμού.
Η διαφορά μεταξύ του όρου if στην Haskell και στις άλλες γλώσσες προγραμματισού είναι ότι το else κομμάτι είναι υποχρεωτικό στην Haskell.
Στις προστακτικές γλώσσες μπορείς απλώς να παρακάμψεις κάποια βήματα αν η προϋπόθεση του όρου if δεν πληρείτε, 
αλλά στην Haskell κάθε έκφραση και κάθε συνάρτηση πρέπει να επιστρέψει κάτι.
Θα μπορούσαμε να είχαμε γράψει τον όρο if σε μία γραμμή, αλλά προσωπικά βρήσκω αυτόν τον τρόπο γραφής πιο ευανάγνωστο.
Ένα άλλο σημαντικό πράγμα για το ιf όρο της Haskell είναι ότι είναι μια <i>έκφραση</i>. 
Μια έκφραση είναι βασικά ένα κομμάτι κώδικα που επιστρέφει μια τιμή.
Το <span class="fixed">5</span> είναι μια έκφραση επειδή επιστρέφει 5, 
το <span class="fixed">4 + 8</span> είναι μια έκφραση, επίσης το <span class="fixed">x + y</span> είναι μια έκφραση επειδή επιστρέφει το άθροισμα των
<span class="fixed">x</span> και <span class="fixed">y</span>. 
Αφού το else τμήμα είναι υποχρεωτικό, κάθε όρος if πάντα θα επιστρέφει κάτι και για τον λόγο αυτό είναι μια έκφραση.
Αν θέλαμε να προσθέσουμε ένα σε κάθε αριθμό που παράγεται από την προηγούμενη συνάρτησή μας, θα μπορούσαμε να είχαμε ορίσει το σώμα της ως εξής: 
</p>
<pre name="code" class="haskell: hs">
doubleSmallNumber' x = (if x &gt; 100 then x else x*2) + 1
</pre>
<p>
Αν παραλείψουμε την παρένθεση, θα προσθέταμε ένα μόνο όταν το <span class="fixed">x</span> δεν είναι μεγαλύτερο από 100.
Προσέψτε το <span class="fixed">'</span> στο τέλος του ονόματος της συνάρτησης.
Η απόστροφος δεν έχει κάποιο ειδικό νόημα στην σύνταξη της Haskell.
Είναι ένας χαρακτύρας που μπορούμε έγκυρα να χρησιμοποιούμε σε ονόματα συναρτήσεων.
Συνήθως χρησιμοποιούμε <span class="fixed">'</span> να ορίσουμε μια οκνηρή εκδοχή μιας συνάρτησης (μια εκδοχή που δεν είναι οκνηρή) ή μια λίγο αλλαγμένη εκδοχή μιας συνάρτησης ή μεταβλητής.
Επειδή ο χαρακτήρας <span class="fixed">'</span> είναι ένας έγκυρος χαρακτήρας σε ονόματα συναρτήσεων, 
μπορείτε να ορίσετε μια συνάρτηση ως εξής:
</p>
<pre name="code" class="haskell: hs">
conanO'Brien = "It's a-me, Conan O'Brien!" </pre>
<p>
Υπάρχουν δύο αξιοσημείωτα πράγματα εδώ.
Το πρώτο είναι ότι στον όνομα της συνάρτησης δεν μπορούμς να χρησημοποιήσουμε κεφαλαίους χαρακτήρες για τον όνομα του Conan. 
Αυτό συμβαίνει επεισή τα ονόματα συναρτήσεων δεν μπορούν να ξεκινούν με κεφαλαίους χαρακτήρες. Θα δούμε αργότερα το γιατί.
Το δέυτερο που αξίζει να σημειωθεί είναι ότι αυτή η συνάρτηση δεν δέχεται κανένα όρισμα.
Όταν μια συνάρτηση δεν δέχεται κανένα όρισμα, λέμε ότι είναι ένας <i>ορισμός</i> (ή ένα <i>όνομα</i>). 
Επειδή δεν μπορούμε να αλλάξουμε την σημασία των ονομάτων (και των συναρήσεων) 
αφού τα ορίσουμε, το όνομα <span class="fixed">conanO'Brien</span> και η ακολουθία χαρακτήρων <span class="fixed">"It's a-me, Conan O'Brien!"</span> είναι ισοδύναμα.
</p>
<a name="an-intro-to-lists"></a><h2>Εισαγωγή στις λίστες</h2>
<p>
<img src="../s3.amazonaws.com/lyah/list.png" alt="BUY A DOG" class="left" width="150" height="103">
Όπως η λίστα του σούπερ μάρκετ, οι λίστες στην Haskell είναι πολύ χρησιμες. 
Είναι η πιο χρησιμη δομή δεδομένων και μπορεί να χρησιμοποιηθεί με πολλαπλούς διαφορετικούς τρόπους 
για να μοντελοποιήσει και να λύσει πολλά προβλήματα.
Οι λίστες είναι καταπληκτικές!
Σε αυτήν την ενότητα θα δούμε την βάση των λιστών, των ακολουθιών χαρακτήρων (που είναι λίστες) και τον διαχωρισμό λιστών.
</p>
<p>
Στην Haskell, η λίστα είναι μια <em>ομοιογενής</em> δομή δεδομένων. 
Περιέχει πολλά στοιχεία του ίδιου τύπου.
Αυτό σημαίνει ότι μπορεί να έχουμε μία λίστα ακεραίων ή μία λίστα χαρατκήρων, αλλά δεν μπορούμε να έχουμε μία λίστα που περιέχει μερικούς χαρακτήρες και μερικούς ακεραίους.
Και τώρα, μία λίστα!
</p>
<div class="hintbox"><em>Σημείωση</em>: 
Μπορούμε να χρησιμοποιοήσουμε την λέξη κλειδί <span class="fixed">let</span> 
για να ορίσουμε ένα όνομα στον GHCI. 
Το να γράψουμε <span class="fixed">let a = 1</span> στον GHCI 
είναι ισοδύναμο με το να γράψουμε 
<span class="fixed">a = 1</span> σε ένα αρχείο και να το φορτώσουμε. </div>
<pre name="code" class="haskell: ghci">
ghci&gt; let lostNumbers = [4,8,15,16,23,42]
ghci&gt; lostNumbers
[4,8,15,16,23,42]
</pre>
<p>
Όπως βλέπεται, οι λίστες ορίζονται με αγκύλες και οι τιμές μέσα στην λίστα είναι διαχωρισμένες και κόμμα.
Αν δοκιμάσουμε να ορίσουμε την λίστα <span class="fixed">[1,2,'a',3,'b','c',4]</span>, η Haskell 
θα παραπονεθεί ότι οι χαρακτήρες (που ορίζονται ως χαρακτήρες ανάμεσα σε μονά εισαγωγικά)
δεν είναι αριθμοί.
Παρεπιπτόντως, οι ακολουθίες χαρακτήρων είναι απλώς λίστες χαρακτήρων.
Για παράδειγμα, η ακολουθία χαρακτήρων <span class="fixed">"hello"</span> 
είναι απλώς "συντακτική ζάχαρη" για την λίστα <span class="fixed">['h','e','l','l','o']</span>.
Επειδή οι ακολουθίες χαρακτήρων είναι λίστες, 
μπορούμε να τις επεξεργαστούμε χρησιμοποιοώντας συναρτήσεις λιστών, 
που είναι πολύ βολικό.
</p>
<p>
Μια πολύ κοινή διεργασία είναι η συνένωση δύο λιστών. 
Αυτό το επιτυγχάνουμε με τον τελεστή <span class="fixed">++</span>. </p>
<pre name="code" class="haskell: ghci">
ghci&gt; [1,2,3,4] ++ [9,10,11,12]
[1,2,3,4,9,10,11,12]
ghci&gt; "hello" ++ " " ++ "world"
"hello world"
ghci&gt; ['w','o'] ++ ['o','t']
"woot"
</pre>
<p>
Πρέπει να προσέχεται όταν χρησιμοποιείται τον τελεστή <span class="fixed">++</span> σε μεγάλες ακολουθίες.
Όταν συνενώνεται δύο λίστες, (ακόμα και αν απλώς προσθέτεται ένα μόνο στοιχείο στο τέλος την πρώτης λίστασ, 
όπως για παράδειγμα στην έκφραση <span class="fixed">[1,2,3] ++ [4]</span>), 
εσωτερικά, η Haskell πρέπει να διασχύση όλην την λίστα στο δεξί μέλος του <span class="fixed">++</span>.
Αυτό δεν είναι πρόβλημα όταν η λίστα δεν είναι μεγάλη. 
Αλλά αν προσθέσεται κάτι στο τέλος μιας λίστας που έχει εκατό χιλιάδες στοιχεία θα πάρει κάποιο χρόνο.
Από την άλλη, η προσθήκη ενός στοιχείου στην αρχή μιας λίστας χρησιμοποιώντας τον τελεστή
<span class="fixed">:</span> (που επίσης ονομάζεται προσθήκη κεφαλής) είναι άμεση.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; 'A':" SMALL CAT"
"A SMALL CAT"
ghci&gt; 5:[1,2,3,4,5]
[5,1,2,3,4,5]
</pre>
<p>
Προσέξτε ότι ο τελεστής <span class="fixed">:</span> δέχεται έναν αριθμό και μία λίστα αριθμών 
ή έναν χαρακτήρα και μία λίστα χαρακτήρων, 
ενώ ο τελεστής
<span class="fixed">++</span> δέχεται δύο λίστες.
Ακόμα και αν προσθέτεται ένα μόνο στοιχείο στο τέλος μίας λίστας με τον τελεστή <span class="fixed">++</span>, πρέπει να το περικλείσεται σε αγκύλες, ώστε να το μετατρέψετε σε λίστα.
</p>
<p>
Στην πραγματικότητα η έκφραση 
<span class="fixed">[1,2,3]</span> 
είναι απλώς συντακτική ζάχαρη για την έκφραση <span class="fixed">1:2:3:[]</span>. 
Η έκφραση <span class="fixed">[]</span> είναι η κενή λίστα. 
Αν προσθέσουμε το <span class="fixed">3</span> στην κενή λίστα, παίρνουμε <span class="fixed">[3]</span>. 
Αν προσθέσουμε <span class="fixed">2</span> σε αυτό, γίνεται <span class="fixed">[2,3]</span>, κτλ.
</p>
<p class="hintbox"><em>Σημείωση:</em> Οι εκφράσεις <span class="fixed">[]</span>, <span class="fixed">[[]]</span> και<span class="fixed">[[],[],[]]</span> είναι τελείως διαφορετικές.
Η πρώτη είναι η κενή λίστα, 
η δεύτερη είναι μία λίστα που περιέχει ένα στοιχείο: την κενή λίστα, 
η τρίτη είναι μια λίστα που περιέχει τρεις κενές λίστες.
</p>
<p>Αν θέλετε να προσπελάσετε ένα στοιχείο μιας λίστας με βάση την θέση του, χρησιμοποιήστε
<span class="fixed">!!</span>. Οι θέσεις ξεκινάνε από το 0.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; "Steve Buscemi" !! 6
'B'
ghci&gt; [9.4,33.2,96.2,11.2,23.25] !! 1
33.2
</pre>
<p>Αλλά αν προσπαθήσετε να προσπελάσετε το έκτο στοιχείο μιας λίστας που έχει μόνο τέσσερα στοιχεία, 
θα πάρετε σφάλμα, για αυτό να είστε προσεκτικοί!</p>
<p>
Οι λίστες μπορούν να περιέχουν λίστες.
Μπορούν επίσης να περιέχουν λίστες που περιέχουν λίστες &hellip;
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b ++ [[1,1,1,1]]
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
ghci&gt; [6,6,6]:b
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b !! 2
[1,2,2,3,4] </pre>
<p>
Οι λίστες μέσα στις λίστες μπορούν να έχουν διαφορετικό μήκος, αλλά δεν μπορούν να περιέχουν στοιχεία διαφορετικών τύπων.
Ακριβώς όπως δεν μπορείτε να έχετε μια λίστα που περιέχει μερικούς χαρακτήρες και μερικούς αριθμούς, 
δεν μπορείτε να έχετε μια λίστα που περιέχει κάποιες λίστες χαρακτήρων και κάποιες λίστες αριθμών.
</p>
<p>Οι λίστες μπορούνε να συγκριθούν, αν τα στοιχεία που περιέχουν μπορούν να συγκριθούν.
Όταν χρησιμοποιούμε τους τελεστές <span class="fixed">&lt;</span>, <span class="fixed">&lt;=</span>, <span class="fixed">&gt;</span> και <span class="fixed">&gt;=</span> για να συγκρίνουμε λίστες, 
τις συγκρίνουμε με λεξικογραφική διάταξη.
Στην αρχή συγκρίνουμε τις κεφαλές. 
Αν είναι ίσες τα δεύτερα στοιχεία συγκίνονται, κτλ.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [3,2,1] &gt; [2,1,0]
True
ghci&gt; [3,2,1] &gt; [2,10,100]
True
ghci&gt; [3,4,2] &gt; [3,4]
True
ghci&gt; [3,4,2] &gt; [2,4]
True
ghci&gt; [3,4,2] == [3,4,2]
True
</pre>
<p>
Τι άλλο μπορούμε να κάνουμε με τις λίστες;
Ακολουθούν μερικές βασικές συναρτήσεις που χειρίζονται λίστες.
</p>
<p>Η συνάρτηση <span class="label function">head</span> δέχεται μια λίστα και επιστρέφει την κεφαλή της.
Η κεφαλή μιας λίστας είναι ουσιαστικά το πρώτο στοιχείο της λίστας.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; head [5,4,3,2,1]
5 </pre>
<p>Η συνάρτηση <span class="label function">tail</span> δέχεται μια λίστα και επιστρέφει την ουρά της. 
Με άλλα λόγια πετάει την κεφαλή της λίστας.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; tail [5,4,3,2,1]
[4,3,2,1] </pre>
<p>Η συνάρτηση <span class="label function">last</span> δέχεται μια λίστα και επιστρέφει το τελευταίο στοιχείο της.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; last [5,4,3,2,1]
1 </pre>
<p>Η συνάρτηση <span class="label function">init</span> δέχεται μια λίστα και επιστρέφει μια λίστα με όλα τα στοιχεία της αρχικής, εκτός από το τελευταίο.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; init [5,4,3,2,1]
[5,4,3,2] </pre>
<p>Αν η λίστα ήταν τέρας, τότε θα έμοιαζε με</p>
<img src="../s3.amazonaws.com/lyah/listmonster.png" alt="list monster" class="center" width="580" height="290">
<p>Τι θα συμβεί αν επιχειρήσουμε να πάρουμε την κεφαλή μιας κενής λίστας;
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; head []
*** Exception: Prelude.head: empty list</pre>
<p>Ουπς! Έσκασε στα χέρια μας!
Αν δεν υπάρχει τέρας, τότε δεν έχει κεφάλι.
Όταν χρησιμοποιείτε τις συναρτήσεις
<span class="fixed">head</span>, <span class="fixed">tail</span>, <span class="fixed">last</span> και <span class="fixed">init</span>, 
προσέχτε να μην τις χρησιμοποιείτε σε κενές λίστες.
Αυτό το σφάλμα δεν ανιχνεύεται την στιγμή μεταγλώττισης
για τον λόγο αυτό πρέπει πάντα να προσέχεται ώστε να μην πείτε, κατά λάθος, στην Haskell να σας δώσει στοιχεία κενής λίστας.
<p>Η συνάρτηση <span class="label function">length</span> δέχεται μία λίστα και επιστρέφει το μήκος της.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; length [5,4,3,2,1]
5</pre>
<p>Η συνάρτηση <span class="label function">null</span> ελέγχει αν λία λίστα είναι κενή.
Αν η λίστα είναι κενή, επιστρέφει <span class="fixed">True</span>, διαφορετικά, επιστρέφει <span class="fixed">False</span>. 
Καλό είναι να χρησιμοποιείτε αυτήν την συνάρτηση, αντί για τον έλεγχο <span class="fixed">xs == []</span> 
(για κάποια λίστα <span class="fixed">xs</span>)</p>
<pre name="code" class="haskell: ghci">
ghci&gt; null [1,2,3]
False
ghci&gt; null []
True</pre>
<p>Η συνάρτηση <span class="label function">reverse</span> αντιστρέφει μια λίστα.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; reverse [5,4,3,2,1]
[1,2,3,4,5]</pre>
<p>Η συνάρτηση <span class="label function">take</span> δέχεται έναν αριθμό και μία λίστα. 
Επιστρέφει τόσα στοιχεία από την αρχή της λίστας.
Κοιτάξτε.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; take 3 [5,4,3,2,1]
[5,4,3]
ghci&gt; take 1 [3,9,3]
[3]
ghci&gt; take 5 [1,2]
[1,2]
ghci&gt; take 0 [6,6,6]
[]</pre>
<p>Προσέξτε ότι αν προσπαθήσουμε να πάρουμε στειχεία πιο πολλά από όσα περιέχει η λίστα, 
απλώς επιστρέφεται η λίστα. 
Αν προσπαθήσουμε να πάρουμε 0 στοιχεία, επιστρέφεται η κενή λίστα.
</p>
<p>Η συνάρτηση <span class="label function">drop</span> δουλεύει με παρόμοιο τρόπο, αλλά πετάει τα στειχεί ααπό την αρχή της λίστας.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; drop 3 [8,4,2,1,5,6]
[1,5,6]
ghci&gt; drop 0 [1,2,3,4]
[1,2,3,4]
ghci&gt; drop 100 [1,2,3,4]
[] </pre>
<p>Η συνάρτηση <span class="label function">maximum</span> δέχεται μια λίστα στοιχείων που μπορούνα να διαταχθούν και επιστρέφει το μεγαλύτερο στοιχείο.
</p><p> Η συνάρτηση <span class="label function">minimum</span> επιστρέφει το μικρότερο στοιχείο της λίστας.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; minimum [8,4,2,1,5,6]
1
ghci&gt; maximum [1,9,2,3,4]
9 </pre>
<p>Η συνάρτηση <span class="label function">sum</span> δέχεται μια λίστα αριθμών και επιστρέφει το άθροισμα τψν στοιχείων της.</p>
<p>Η συνάρτηση <span class="label function">product</span> δέχεται μια λίστα αριθμών και επιστρέφει το γινόμενο των στοιχείων της.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; sum [5,2,1,6,3,2,5,7]
31
ghci&gt; product [6,2,1,2]
24
ghci&gt; product [1,2,5,6,7,9,2,0]
0 </pre>
<p>Η συνάρτηση <span class="label function">elem</span> δέχεται ένα στοιχείο και μία λίστα στοιχείων και μας λέει αν το στοιχείο ανήκει στην λίστα.
Συνήθως καλείται σαν ένθετος τελεστής, γιατί είναι πιο ευανάγνωστο.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; 4 `elem` [3,4,5,6]
True
ghci&gt; 10 `elem` [3,4,5,6]
False
</pre>
<p>Αυτές είναι κάποιες βασικές συναρτήσεις λιστών.
Θα δούμε περισσότερες συναρτήσεις λιστών, 
<a href="modules.html#data-list">αργότερα</a></p>
<a name="texas-ranges"></a><h2>Texas ranges</h2>
<p>
<img src="../s3.amazonaws.com/lyah/cowboy.png" alt="draw" class="right" width="200" height="258">
What if we want a list of all numbers between 1 and 20? Sure, we could just type them all out but obviously that's not a solution for gentlemen who demand excellence from their programming languages. Instead, we'll use ranges. Ranges are a way of making lists that are arithmetic sequences of elements that can be enumerated. Numbers can be enumerated. One, two, three, four, etc. Characters can also be enumerated. The alphabet is an enumeration of characters from A to Z. Names can't be enumerated. What comes after "John"? I don't know.
</p>
<p>To make a list containing all the natural numbers from 1 to 20, you just write <span class="fixed">[1..20]</span>. That is the equivalent of writing <span class="fixed">[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</span> and there's no difference between writing one or the other except that writing out long enumeration sequences manually is stupid.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [1..20]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
ghci&gt; ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci&gt; ['K'..'Z']
"KLMNOPQRSTUVWXYZ" </pre>
<p>
Ranges are cool because you can also specify a step. What if we want all even numbers between 1 and 20? Or every third number between 1 and 20?
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [2,4..20]
[2,4,6,8,10,12,14,16,18,20]
ghci&gt; [3,6..20]
[3,6,9,12,15,18] </pre>
<p>It's simply a matter of separating the first two elements with a comma and then specifying what the upper limit is. While pretty smart, ranges with steps aren't as smart as some people expect them to be. You can't do <span class="fixed">[1,2,4,8,16..100]</span> and expect to get all the powers of 2. Firstly because you can only specify one step. And secondly because some sequences that aren't arithmetic are ambiguous if given only by a few of their first terms.
</p>
<p>To make a list with all the numbers from 20 to 1, you can't just do <span class="fixed">[20..1]</span>, you have to do <span class="fixed">[20,19..1]</span>.</p>
<p>Watch out when using floating point numbers in ranges! Because they are not completely precise (by definition), their use in ranges can yield some pretty funky results.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [0.1, 0.3 .. 1]
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
</pre>
<p>My advice is not to use them in list ranges.</p>
<p>
You can also use ranges to make infinite lists by just not specifying an upper limit. Later we'll go into more detail on infinite lists. For now, let's examine how you would get the first 24 multiples of 13. Sure, you could do <span class="fixed">[13,26..24*13]</span>. But there's a better way: <span class="fixed">take 24 [13,26..]</span>. Because Haskell is lazy, it won't try to evaluate the infinite list immediately because it would never finish. It'll wait to see what you want to get out of that infinite lists. And here it sees you just want the first 24 elements and it gladly obliges.
</p>
<p>A handful of functions that produce infinite lists:</p>
<p><span class="label function">cycle</span> takes a list and cycles it into an infinite list. If you just try to display the result, it will go on forever so you have to slice it off somewhere.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; take 10 (cycle [1,2,3])
[1,2,3,1,2,3,1,2,3,1]
ghci&gt; take 12 (cycle "LOL ")
"LOL LOL LOL " </pre>
<p><span class="label function">repeat</span> takes an element and produces an infinite list of just that element. It's like cycling a list with only one element.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; take 10 (repeat 5)
[5,5,5,5,5,5,5,5,5,5]
</pre>
<p>Although it's simpler to just use the <span class="label function">replicate</span> function if you want some number of the same element in a list. <span class="fixed">replicate 3 10</span> returns <span class="fixed">[10,10,10]</span>.</p>
<a name="im-a-list-comprehension"></a><h2>I'm a list comprehension</h2>
<p>
<img src="../s3.amazonaws.com/lyah/kermit.png" alt="frog" class="left" width="180" height="156">
If you've ever taken a course in mathematics, you've probably run into <i>set comprehensions</i>. They're normally used for building more specific sets out of general sets. A basic comprehension for a set that contains the first ten even natural numbers is <img src="../s3.amazonaws.com/lyah/setnotation.png" alt="set notation">. The part before the pipe is called the output function, <span class="fixed">x</span> is the variable, <span class="fixed">N</span> is the input set and <span class="fixed">x &lt;= 10</span> is the predicate. That means that the set contains the doubles of all natural numbers that satisfy the predicate.
</p>
<p>If we wanted to write that in Haskell, we could do something like <span class="fixed">take 10 [2,4..]</span>. But what if we didn't want doubles of the first 10 natural numbers but some kind of more complex function applied on them? We could use a list comprehension for that. List comprehensions are very similar to set comprehensions. We'll stick to getting the first 10 even numbers for now. The list comprehension we could use is <span class="fixed">[x*2 | x &lt;- [1..10]]</span>. <span class="fixed">x</span> is drawn from <span class="fixed">[1..10]</span> and for every element in <span class="fixed">[1..10]</span> (which we have bound to <span class="fixed">x</span>), we get that element, only doubled. Here's that comprehension in action. </p>
<pre name="code" class="haskell: ghci">
ghci&gt; [x*2 | x <- [1..10]]
[2,4,6,8,10,12,14,16,18,20]
</pre>
<p>As you can see, we get the desired results. Now let's add a condition (or a predicate) to that comprehension. Predicates go after the binding parts and are separated from them by a comma. Let's say we want only the elements which, doubled, are greater than or equal to 12.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [x*2 | x <- [1..10], x*2 >= 12]
[12,14,16,18,20]
</pre>
<p>Cool, it works. How about if we wanted all numbers from 50 to 100 whose remainder when divided with the number 7 is 3? Easy.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [ x | x &lt;- [50..100], x `mod` 7 == 3]
[52,59,66,73,80,87,94] </pre>
<p>Success! Note that weeding out lists by predicates is also called <em>filtering</em>. We took a list of numbers and we filtered them by the predicate. Now for another example. Let's say we want a comprehension that replaces each odd number greater than 10 with <span class="fixed">"BANG!"</span> and each odd number that's less than 10 with <span class="fixed">"BOOM!"</span>. If a number isn't odd, we throw it out of our list. For convenience, we'll put that comprehension inside a function so we can easily reuse it.</p>
<pre name="code" class="haskell: ghci">
boomBangs xs = [ if x &lt; 10 then "BOOM!" else "BANG!" | x &lt;- xs, odd x] </pre>
<p>The last part of the comprehension is the predicate. The function <span class="fixed">odd</span> returns <span class="fixed">True</span> on an odd number and <span class="fixed">False</span>  on an even one. The element is included in the list only if all the predicates evaluate to <span class="fixed">True</span>.
<pre name="code" class="haskell: hs">
ghci&gt; boomBangs [7..13]
["BOOM!","BOOM!","BANG!","BANG!"] </pre>
<p>We can include several predicates. If we wanted all numbers from 10 to 20 that are not 13, 15 or 19, we'd do:</p> <pre name="code" class="haskell: ghci">
ghci&gt; [ x | x &lt;- [10..20], x /= 13, x /= 15, x /= 19]
[10,11,12,14,16,17,18,20]</pre>
<p>Not only can we have multiple predicates in list comprehensions (an element must satisfy all the predicates to be included in the resulting list), we can also draw from several lists. When drawing from several lists, comprehensions produce all combinations of the given lists and then join them by the output function we supply. A list produced by a comprehension that draws from two lists of length 4 will have a length of 16, provided we don't filter them. If we have two lists, <span class="fixed">[2,5,10]</span> and <span class="fixed">[8,10,11]</span> and we want to get the products of all the possible combinations between numbers in those lists, here's what we'd do.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]
[16,20,22,40,50,55,80,100,110] </pre>
<p>As expected, the length of the new list is 9. What if we wanted all possible products that are more than 50?</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11], x*y &gt; 50]
[55,80,100,110] </pre>
<p>How about a list comprehension that combines a list of adjectives and a list of nouns &hellip; for epic hilarity.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; let nouns = ["hobo","frog","pope"]
ghci&gt; let adjectives = ["lazy","grouchy","scheming"]
ghci&gt; [adjective ++ " " ++ noun | adjective &lt;- adjectives, noun &lt;- nouns]
["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",
"grouchy pope","scheming hobo","scheming frog","scheming pope"] </pre>
<p>I know! Let's write our own version of <span class="fixed">length</span>! We'll call it <span class="fixed">length'</span>.</p>
<pre name="code" class="haskell: hs">
length' xs = sum [1 | _ &lt;- xs] </pre>
<p><span class="fixed">_</span> means that we don't care what we'll draw from the list anyway so instead of writing a variable name that we'll never use, we just write <span class="fixed">_</span>. This function replaces every element of a list with <span class="fixed">1</span> and then sums that up. This means that the resulting sum will be the length of our list.</p>
<p>Just a friendly reminder: because strings are lists, we can use list comprehensions to process and produce strings. Here's a function that takes a string and removes everything except uppercase letters from it.</p>
<pre name="code" class="haskell: hs">
removeNonUppercase st = [ c | c &lt;- st, c `elem` ['A'..'Z']] </pre>
<p>
Testing it out:
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; removeNonUppercase "Hahaha! Ahahaha!"
"HA"
ghci&gt; removeNonUppercase "IdontLIKEFROGS"
"ILIKEFROGS" </pre>
<p>The predicate here does all the work. It says that the character will be included in the new list only if it's an element of the list <span class="fixed">['A'..'Z']</span>. Nested list comprehensions are also possible if you're operating on lists that contain lists. A list contains several lists of numbers. Let's remove all odd numbers without flattening the list.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
ghci&gt; [ [ x | x &lt;- xs, even x ] | xs &lt;- xxs]
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]
</pre>
<p>You can write list comprehensions across several lines. So if you're not in GHCI, it's better to split longer list comprehensions across multiple lines, especially if they're nested.</p>
<a name="tuples"></a><h2>Tuples</h2>
<img src="../s3.amazonaws.com/lyah/tuple.png" alt="tuples" class="right" width="160" height="162">
<p>In some ways, tuples are like lists &mdash; they are a way to store several values into a single value. However, there are a few fundamental differences. A list of numbers is a list of numbers. That's its type and it doesn't matter if it has only one number in it or an infinite amount of numbers. Tuples, however, are used when you know exactly how many values you want to combine and its type depends on how many components it has and the types of the components. They are denoted with parentheses and their components are separated by commas.</p>
<p>Another key difference is that they don't have to be homogenous. Unlike a list, a tuple can contain a combination of several types.</p>
<p>Think about how we'd represent a two-dimensional vector in Haskell. One way would be to use a list. That would kind of work. So what if we wanted to put a couple of vectors in a list to represent points of a shape on a two-dimensional plane? We could do something like <span class="fixed">[[1,2],[8,11],[4,5]]</span>. The problem with that method is that we could also do stuff like <span class="fixed">[[1,2],[8,11,5],[4,5]]</span>, which Haskell has no problem with since it's still a list of lists with numbers but it kind of doesn't make sense. But a tuple of size two (also called a pair) is its own type, which means that a list can't have a couple of pairs in it and then a triple (a tuple of size three), so let's use that instead. Instead of surrounding the vectors with square brackets, we use parentheses: <span class="fixed">[(1,2),(8,11),(4,5)]</span>. What if we tried to make a shape like <span class="fixed">[(1,2),(8,11,5),(4,5)]</span>? Well, we'd get this error:</p>
<pre name="code" class="haskell: ghci">
Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]
</pre>
<p>It's telling us that we tried to use a pair and a triple in the same list, which is not supposed to happen. You also couldn't make a list like <span class="fixed">[(1,2),("One",2)]</span> because the first element of the list is a pair of numbers and the second element is a pair consisting of a string and a number. Tuples can also be used to represent a wide variety of data. For instance, if we wanted to represent someone's name and age in Haskell, we could use a triple: <span class="fixed">("Christopher", "Walken", 55)</span>. As seen in this example, tuples can also contain lists.</p>
<p>Use tuples when you know in advance how many components some piece of data should have. Tuples are much more rigid because each different size of tuple is its own type, so you can't write a general function to append an element to a tuple &mdash; you'd have to write a function for appending to a pair, one function for appending to a triple, one function for appending to a 4-tuple, etc.</p>
<p>While there are singleton lists, there's no such thing as a singleton tuple. It doesn't really make much sense when you think about it. A singleton tuple would just be the value it contains and as such would have no benefit to us.</p>
<p>Like lists, tuples can be compared with each other if their components can be compared. Only you can't compare two tuples of different sizes, whereas you can compare two lists of different sizes. Two useful functions that operate on pairs:</p>
<p><span class="label function">fst</span> takes a pair and returns its first component.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; fst (8,11)
8
ghci&gt; fst ("Wow", False)
"Wow"</pre>
<p><span class="label function">snd</span> takes a pair and returns its second component. Surprise!</p>
<pre name="code" class="haskell: ghci">
ghci&gt; snd (8,11)
11
ghci&gt; snd ("Wow", False)
False</pre>
<div class="hintbox"><em>Note:</em> these functions operate only on pairs. They won't work on triples, 4-tuples, 5-tuples, etc. We'll go over extracting data from tuples in different ways a bit later.</div>
<p>A cool function that produces a list of pairs: <span class="label function">zip</span>. It takes two lists and then zips them together into one list by joining the matching elements into pairs. It's a really simple function but it has loads of uses. It's especially useful for when you want to combine two lists in a way or traverse two lists simultaneously. Here's a demonstration.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; zip [1,2,3,4,5] [5,5,5,5,5]
[(1,5),(2,5),(3,5),(4,5),(5,5)]
ghci&gt; zip [1 .. 5] ["one", "two", "three", "four", "five"]
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
</pre>
<p>It pairs up the elements and produces a new list. The first element goes with the first, the second with the second, etc. Notice that because pairs can have different types in them, <span class="fixed">zip</span> can take two lists that contain different types and zip them up. What happens if the lengths of the lists don't match?</p>
<pre name="code" class="haskell: ghci">
ghci&gt; zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
[(5,"im"),(3,"a"),(2,"turtle")]
</pre>
<p>The longer list simply gets cut off to match the length of the shorter one. Because Haskell is lazy, we can zip finite lists with infinite lists:</p>
<pre name="code" class="haskell: ghci">
ghci&gt; zip [1..] ["apple", "orange", "cherry", "mango"]
[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]
</pre>
<img src="../s3.amazonaws.com/lyah/pythag.png" alt="look at meee" class="center" width="350" height="315">
<p>Here's a problem that combines tuples and list comprehensions: which right triangle that has integers for all sides and all sides equal to or smaller than 10 has a perimeter of 24? First, let's try generating all triangles with sides equal to or smaller than 10:</p>
<pre name="code" class="haskell: ghci">ghci&gt; let triangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..10], a &lt;- [1..10] ] </pre>
<p>We're just drawing from three lists and our output function is combining them into a triple. If you evaluate that by typing out <span class="fixed">triangles</span> in GHCI, you'll get a list of all possible triangles with sides under or equal to 10. Next, we'll add a condition that they all have to be right triangles. We'll also modify this function by taking into consideration that side b isn't larger than the hypothenuse and that side a isn't larger than side b.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; let rightTriangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2] </pre>
<p>We're almost done. Now, we just modify the function by saying that we want the ones where the perimeter is 24.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; let rightTriangles' = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
ghci&gt; rightTriangles'
[(6,8,10)]
</pre>
<p>And there's our answer! This is a common pattern in functional programming. You take a starting set of solutions and then you apply transformations to those solutions and filter them until you get the right ones.</p>
                <div class="footdiv">
                <ul>
                    <li style="text-align:left">
                                                        <a href="introduction.html" class="prevlink">Εισαγωγή</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters.html">Περιεχόμενα</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="types-and-typeclasses.html" class="nxtlink">Τύποι και κλάσεις τύπων</a>
                                            </li>
                </ul>
            </div>
        </div>
    <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
    <script type="text/javascript" src="shBrushHaskell.js"></script>
    <script type="text/javascript" src="shBrushPlain.js"></script>
    <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = 'sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script>
</body>

<!-- Mirrored from learnyouahaskell.com/starting-out by HTTrack Website Copier/3.x [XR&CO'2008], Wed, 25 Jun 2014 15:12:22 GMT -->
</html>
